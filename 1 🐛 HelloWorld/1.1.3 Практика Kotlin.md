Игра Угадай число

```kotlin
import kotlin.random.Random

fun main() {
    println("Добро пожаловать в игру 'Угадай число'!")
    println("Я загадал число от 1 до 100. Попробуй угадать!")

    val secretNumber = Random.nextInt(1, 101) // Генерация случайного числа
    var attempts = 0
    var hasGuessed = false
    var points = 100

    while (!hasGuessed) {
        attempts++
        print("Введи свой вариант (попытка $attempts, очков: $points): ")
        val input = readLine()

        val guess = input?.toIntOrNull() // Преобразуем ввод в Int? (null, если не число)

        if (guess == null) {
            println("Пожалуйста, введи целое число.")
            continue // Переходим к следующей итерации цикла
        }

        when {
            guess < secretNumber -> {
                println("Загаданное число больше.")
                points -= 10
            }
            guess > secretNumber -> {
                println("Загаданное число меньше.")
                points -= 10
            }
            else -> {
                hasGuessed = true
                println("Поздравляю! Ты угадал число $secretNumber за $attempts попыток и заработал $points очков!")
            }
        }
        if (points <= 0) {
          println("Вы проиграли, ваши очки кончились! Загаданное число $secretNumber")
          return
        }
    }

    println("Хочешь сыграть еще раз? (y/n)")
    val playAgain = readLine()
    if(playAgain?.lowercase() == "y") { //приводим к нижнему регистру
        main() // Рекурсивный вызов функции main для новой игры
    } else {
        println("Спасибо за игру!")
    }
}
```
**Разбор кода финального приложения:**

1.  **`import kotlin.random.Random`:** Импортируем класс `Random` для генерации случайных чисел.
2.  **`main()`:** Главная функция, точка входа в программу.
3.  **Приветствие:** Выводим приветствие и правила игры.
4.  **`Random.nextInt(1, 101)`:** Генерируем случайное число от 1 до 100 (включительно). Обратите внимание, что верхняя граница *не* включается, поэтому мы используем 101.
5.  **`attempts`, `hasGuessed`, `points`:** Переменные для отслеживания количества попыток, статуса угадывания и очков.
6.  **`while (!hasGuessed)`:** Цикл, который продолжается, пока игрок не угадает число.
7.  **`readLine()`:** Считываем ввод пользователя с консоли.  Возвращает `String?` (может быть `null`, если ввод пустой).
8.  **`input?.toIntOrNull()`:**  Пытаемся преобразовать введенную строку в целое число.  Если преобразование не удалось (например, пользователь ввел буквы), результатом будет `null`.  Используем безопасный вызов (`?.`), чтобы избежать ошибки.
9.  **`if (guess == null)`:** Проверяем, удалось ли преобразование в число.  Если нет, выводим сообщение об ошибке и используем `continue`, чтобы перейти к следующей итерации цикла, не выполняя остальной код.
10. **`when`:**  Проверяем, больше ли, меньше ли или равно введенное число загаданному.  В зависимости от результата выводим подсказку и уменьшаем количество очков.
11. **`hasGuessed = true`:**  Если число угадано, устанавливаем флаг `hasGuessed` в `true`, чтобы выйти из цикла.
12. **Проверка `points`:** Если points меньше или равно 0 завершаем игру.
13. **Предложение сыграть еще:** Спрашиваем пользователя, хочет ли он сыграть еще раз.
14. **`playAgain?.lowercase() == "y"`:**  Проверяем ответ пользователя.  Используем безопасный вызов (`?.`) и приводим строку к нижнему регистру (`lowercase()`), чтобы обработать ответы "Y", "y", "Yes" и т.д.
15. **`main()` (рекурсия):** Если пользователь хочет сыграть еще раз, вызываем функцию `main()` снова – это *рекурсия*.  Начинается новая игра.

*   **Безопасность типов и nullability:**  Активно используем nullable типы (`String?`, `Int?`) и операторы `?.`, `?:` для безопасной работы с потенциально отсутствующими значениями.
*   **Вывод типов:**  Не указываем типы явно там, где Kotlin может вывести их сам (например, `val secretNumber = ...`).
*   **`when` как выражение:**  Используем `when` для более компактной и выразительной проверки условий.
*   **`continue` в цикле:**  Используем `continue` для перехода к следующей итерации цикла без выполнения лишнего кода.
*   **Однострочные функции:** Функция `main` хоть и многострочная, но мы могли бы, теоретически, сделать и другие функции в одну строчку, как `multiply` в прошлом примере.
* **Рекурсия:** Используем рекурсию для перезапуска игры, что является интересным примером, хотя в production коде рекурсию стоит применять осторожно.
* **Работа со строками:** Применяется `lowercase()`.
* **Импорты:** Импортируем только то, что необходимо (`kotlin.random.Random`).
