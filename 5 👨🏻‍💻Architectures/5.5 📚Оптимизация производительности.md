Что такое оптимизация? Это процесс улучшения производительности приложения, чтобы оно работало *быстрее*, *плавнее*, потребляло *меньше ресурсов* (память, процессор, батарея) и *лучше* взаимодействовало с пользователем. Мы будем использовать мощные инструменты *профилирования* (CPU Profiler, Memory Profiler, Network Profiler), *Layout Inspector*.



**1. Зачем нужна оптимизация производительности?**

*   **Улучшение user experience (UX):** Плавная работа, быстрый отклик, отсутствие зависаний – всё это делает приложение более приятным в использовании.
*   **Снижение потребления ресурсов:** Экономия заряда батареи, памяти, трафика.
*   **Повышение стабильности:** Меньше вероятность сбоев и ошибок.
*   **Лучшие отзывы и рейтинги:** Пользователи ценят быстрые и стабильные приложения.
*   **Конкурентное преимущество:** Ваше приложение будет выгодно отличаться от медленных и "глючных" приложений конкурентов.

**2. Инструменты профилирования (Profiling Tools)**

Android Studio предоставляет мощные инструменты профилирования, которые позволяют анализировать производительность приложения и находить узкие места.

*   **CPU Profiler:**  Показывает, сколько времени процессор тратит на выполнение различных частей кода. Помогает найти медленные функции и методы.
*   **Memory Profiler:**  Показывает, как приложение использует память. Помогает найти утечки памяти, большие объекты, частые аллокации/освобождения памяти.
*   **Network Profiler:**  Показывает сетевую активность приложения (запросы, ответы, трафик). Помогает оптимизировать сетевое взаимодействие.
*   **Energy Profiler:** Показывает, как приложение потребляет энергию (батарею).

**Как запустить профайлер:**

1.  Запустите приложение на эмуляторе или реальном устройстве.
2.  В Android Studio откройте вкладку "Profiler" (обычно внизу).
3.  Нажмите кнопку "+" и выберите ваше устройство и процесс приложения.
4.  Выберите нужный профайлер (CPU, Memory, Network, Energy).
5.  Нажмите кнопку "Record" (красный кружок), чтобы начать запись данных.
6.  Взаимодействуйте с приложением.
7.  Нажмите кнопку "Stop" (квадратик), чтобы остановить запись.

**3. CPU Profiler**

CPU Profiler позволяет увидеть, какие функции и методы выполняются дольше всего.

*   **Call Chart:**  Графическое представление вызовов функций (стек вызовов).
*   **Flame Chart:**  Похож на Call Chart, но показывает агрегированное время выполнения функций.
*   **Top Down:**  Список функций, отсортированный по времени выполнения (сверху вниз – от самых "тяжелых" к самым "легким").
*   **Bottom Up:**  Список функций, отсортированный по времени выполнения (снизу вверх – от самых "легких" к самым "тяжелым").

**Типичные проблемы, которые можно найти с помощью CPU Profiler:**

*   **Сложные вычисления в главном потоке:**  Длительные операции (например, обработка изображений, сложные вычисления) не должны выполняться в главном потоке (UI thread), т.к. это приводит к зависанию UI.  Используйте корутины, WorkManager или другие механизмы для выполнения таких операций в фоновом потоке.
*   **Частые вызовы "тяжелых" функций:**  Например, частые обращения к базе данных или сети.  Попробуйте оптимизировать алгоритмы, использовать кэширование.
*   **Неэффективные алгоритмы:**  Используйте более эффективные алгоритмы и структуры данных.
*   **Jank (лаги):**  Пропуски кадров (frame drops) из-за того, что UI не успевает обновиться за 16 мс (60 кадров в секунду).

**4. Memory Profiler**

Memory Profiler позволяет анализировать использование памяти приложением.

*   **Heap Dump:**  Снимок кучи (heap) – всех объектов, которые находятся в памяти в данный момент.
*   **Allocation Tracking:**  Отслеживание аллокаций (выделения) и освобождения памяти.

**Типичные проблемы, которые можно найти с помощью Memory Profiler:**

*   **Утечки памяти (Memory Leaks):**  Объекты, которые больше не используются, но не освобождаются сборщиком мусора (garbage collector).  Это приводит к постепенному увеличению потребления памяти и может привести к `OutOfMemoryError`.
*   **Большие объекты:**  Объекты, которые занимают много памяти (например, большие изображения).  Попробуйте уменьшить размер изображений, использовать кэширование.
*   **Частые аллокации/освобождения памяти:**  Это может привести к фрагментации памяти и замедлению работы приложения.  Попробуйте переиспользовать объекты, использовать пулы объектов (object pools).

**5. Network Profiler**

Network Profiler позволяет анализировать сетевую активность приложения.

*   **Timeline:**  Показывает запросы и ответы в хронологическом порядке.
*   **Connection View:**  Показывает информацию о каждом соединении (URL, метод, заголовки, тело запроса/ответа, время выполнения).

**Типичные проблемы, которые можно найти с помощью Network Profiler:**

*   **Частые сетевые запросы:**  Попробуйте объединить несколько запросов в один, использовать кэширование.
*   **Большие размеры ответов:**  Попробуйте сжимать данные (например, использовать GZIP), оптимизировать формат данных (например, использовать Protocol Buffers вместо JSON).
*   **Медленные запросы:**  Проверьте скорость интернет-соединения, оптимизируйте серверную часть.
*   **Неудачные запросы:**  Проверьте код обработки ошибок.

**6. Layout Inspector**

Layout Inspector – это инструмент, который позволяет анализировать иерархию View (в классическом Android UI) и composable-функций (в Jetpack Compose).

**Как запустить Layout Inspector:**

1.  Запустите приложение на эмуляторе или реальном устройстве.
2.  В Android Studio выберите `Tools` -> `Layout Inspector`.
3.  Выберите ваше устройство и процесс приложения.

**Что можно делать с помощью Layout Inspector:**

*   **Просматривать иерархию View/Composable:**  Видеть, как элементы UI расположены на экране.
*   **Просматривать свойства View/Composable:**  Размеры, отступы, цвета, текст и т.д.
*   **Находить проблемы с layout'ом:**  Например, слишком глубокая вложенность layout'ов, перерисовка (overdraw).
*   **Редактировать layout в режиме реального времени:** (Только для View) Изменять свойства View и сразу видеть результат на экране (полезно для отладки).

**Типичные проблемы, которые можно найти с помощью Layout Inspector:**

*   **Слишком глубокая вложенность layout'ов:**  Это может привести к замедлению отрисовки UI.  Старайтесь использовать `ConstraintLayout`, `Column`, `Row` и `Box` эффективно, избегайте ненужных вложенных layout'ов.
*   **Перерисовка (Overdraw):**  Когда один и тот же пиксель на экране перерисовывается несколько раз (например, несколько слоев фона друг на друге).  Это приводит к ненужной трате ресурсов.  Используйте прозрачность с умом, оптимизируйте фоновые изображения.
* **Большое количество элементов на экране**: Если у вас много элементов, то стоит задуматься, как это можно упростить.

**7. Утечки памяти (Memory Leaks)**

Утечка памяти – это ситуация, когда объект больше не используется, но сборщик мусора не может его освободить, потому что на него есть ссылки.

**Типичные причины утечек памяти в Android:**

*   **Утечки Context:**  Удержание ссылки на `Activity`, `Service` или другой `Context` после того, как он больше не нужен (например, в статическом поле, в callback'е, в анонимном классе).
*   **Утечки слушателей (listeners):**  Не отписываемся от слушателей (например, `LocationListener`, `SensorEventListener`) после того, как они больше не нужны.
*   **Утечки Handler:**  Использование `Handler` неправильным образом (например, создание `Handler` в `Activity` и передача ему сообщений, которые содержат ссылки на `Activity`).
*   **Утечки потоков (threads):**  Неправильное использование потоков (например, создание потока и отсутствие способа его остановить).
*   **Утечки `Bitmap`:**  Неправильная работа с `Bitmap` (например, не вызываем `recycle()`).
*   **Утечки в Jetpack Compose:**
    *   Забыли про `remember` (теряем состояние и создаем объекты заново).
    *   Бесконечные рекомпозиции
    *  Неправильное использование Side Effects (LaunchedEffect, rememberCoroutineScope, DisposableEffect, produceState, etc.)

**Инструменты для поиска утечек памяти:**

*   **Memory Profiler:**  Можно сделать Heap Dump и проанализировать его.
*   **LeakCanary:**  Библиотека, которая автоматически обнаруживает утечки памяти во время выполнения приложения и показывает уведомления.

**Добавление LeakCanary (build.gradle.kts (Module :app)):**

```kotlin
dependencies {
    debugImplementation("com.squareup.leakcanary:leakcanary-android:2.13") 
}
```

LeakCanary автоматически устанавливается и начинает работать при запуске приложения в debug режиме.

**8. Оптимизация Jetpack Compose**

*   **Используйте `remember`:**  `remember` "запоминает" значение между рекомпозициями.  Это позволяет избежать ненужных вычислений и создания новых объектов.
*   **Используйте `derivedStateOf`:**  Если значение одного состояния зависит от значения другого состояния, используйте `derivedStateOf`, чтобы избежать ненужных рекомпозиций.
*   **Используйте `key` в `LazyColumn` и `LazyRow`:**  `key` помогает Compose правильно определять, какие элементы списка изменились, и перерисовывать только их.
*   **Используйте `const val` для констант:**
*   **Избегайте передачи нестабильных (mutable) объектов в composable-функции:**  Если composable-функция принимает в качестве параметра изменяемый объект (например, `mutableListOf`), то Compose будет считать, что этот объект может измениться в любой момент, и будет перерисовывать composable-функцию при каждом изменении *любого* состояния.  Вместо этого передавайте *неизменяемые* объекты (например, `List`) или используйте `@Stable` / `@Immutable` аннотации (но с осторожностью!).
*  **Используйте `Modifier.composed`:**
*   **Не делайте сложные вычисления внутри composable-функций:**  Выносите вычисления в `ViewModel` или используйте `remember` + `derivedStateOf`.
* **Используйте `Lazy` layouts:** Используйте `LazyColumn` и `LazyRow` для отображения списков
* **Используйте `baseline profile`**: Baseline Profiles улучшают скорость выполнения кода примерно на 30% с первого запуска.


**Возможные оптимизации (примеры):**

*   **Утечки памяти:**  Если LeakCanary обнаружит утечки, исправьте их.
*   **CPU:**
    *   Убедитесь, что нет сложных вычислений в composable-функциях.
    *   Используйте `remember` и `derivedStateOf` там, где это необходимо.
    *   Используйте `key` в `LazyColumn`.
*   **Memory:**
    *  Если используются `Bitmap`, убедитесь что вызывается `recycle()`.
* **Layout:**
    * Убедитесь, что нет излишней вложености.

**Пример оптимизации (добавление `key` в `LazyColumn`):**

```kotlin
// MainActivity.kt (в приложении "Список дел")
// ...
LazyColumn {
    items(tasks, key = { task -> task.id }) { task -> // Добавляем key
        TaskItem(
            task = task,
            onTaskClick = { clickedTask ->
                viewModel.onTaskCheckedChange(clickedTask, !clickedTask.isCompleted)
            },
            onDeleteClick = { taskToDelete ->
                viewModel.deleteTask(taskToDelete)
            }
        )
    }
}
// ...
```

**Пример оптимизации (использование `derivedStateOf`):**

Предположим, что мы хотим отображать количество выполненных задач.  Вместо того, чтобы вычислять это значение напрямую в composable-функции, используем `derivedStateOf`:

```kotlin
// MainViewModel.kt (в приложении "Список дел")
// ...
val completedTasksCount: StateFlow<Int> = tasks.map { tasks ->
  tasks.count { it.isCompleted }
}.stateIn(viewModelScope, SharingStarted.WhileSubscribed(5000), 0)

// ...
```

```kotlin
// MainActivity.kt
// ...
val completedTasksCount by viewModel.completedTasksCount.collectAsState()

// ...
Text("Completed tasks: $completedTasksCount")
// ...
```
